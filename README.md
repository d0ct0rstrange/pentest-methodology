# pentest-methodology
An ever updating note with how to conduct a pentest. This methodology isn't meant to be a comprehensive one and this will constantly be updated.

# **Begining of enumeration**
As usual, we start with nmap.
```
nmap -sCV -v {TARGET}
```
This will scan the target with a quick default scripts scan. We will get a basic idea what kind of machine is it.
Once we get the services list, look all the ports calmly.
**DO NOT JUMP INTO EXPLOITING RIGHT AWAY, UNLESS YOU K.N.O.W WHAT YOU ARE DOING!**

If there are web services running in the target, then we should start the directory fuzzing before proceeding into the following,
as it can take a long time to finish. Gotta be efficient! :bowtie:

The point here is to enumerate the following things:

**1. Enumerating OS Version**

**2. Finding Number of ports open**

**3. Finding Name of the service running in EACH and EVERY port!**

**4. FINDING VERSION OF EVERY SERVICE RUNNING! {IMPORTANT AF}**

## **1. Enumerating OS Version**
* **Using Nmap**
```
nmap -sCV -v {IP}
```
covers OS detection. We can also use
```
nmap -O -v {IP}
```
to perform just the OS scan.

* **Using Service Version to enumerate OS Version**

If Nmap couldn't identify the OS version using NSE scripts but, it identified the version of some services, that is shipped with the distribution, 
then we can use that to identify the OS version using a quick google search.
For example, If the OpenSSH version is found as 
```
OpenSSH 7.4p1 Debian
```

We can search the package version in debian packages website and enumerate the OS version.
![os-enum](images/image.png)
Example Google dork:
```
openssh 7.4p1 site:packages.debian.org
```
Sites to search for:

**Debian:** ```packages.debian.org```

**Ubuntu:** ```launchpad.net/ubuntu/```

**Red Hat:** ```rpm.pbone.net```


* **OS enum using TTL**

[Default TTL Values](http://webcache.googleusercontent.com/search?q=cache%3Asubinsb.com%2Fdefault-device-ttl-values%2F&rlz=1C1CHBF_enIN864IN864&oq=cache%3Asubinsb.com%2Fdefault-device-ttl-values%2F&aqs=chrome..69i57j69i58.8312j0j4&sourceid=chrome&ie=UTF-8)


## **2. Finding Number of ports open**

* **Whole ports scan using Nmap**

For TCP

```
nmap -p- -v {IP}
```

For UDP

```
nmap -sU -p- -v {IP}
```

## **3. Finding Name of the service running in EACH and EVERY port!**

* **Nmap Script Scan**

```
nmap -sCV -v {IP}
``` 

OR 

We can use specific scripts. In the below example, we use scripts start with **smb-enum**.

```
nmap --script=smb-enum* -v {IP}
``` 

OR 

We can provide **script type, script name, path to custom script** either individually or all of them together seperated by commas,
as an argument to the script flag.

```
nmap --script default,banner,/home/user/customscripts
```

Where **default** is the script category, **banner** is the script name preloaded with Nmap 
and **/home/user/customscripts** is the path to a custom nse script.

* **Banner Grabbing using NC**

```
nc -nv {IP} {PORT}
```

* **Using Wireshark**

Analyze the traffic that responds when engaged with the target service port.
For example, if we want to enumerate the SMB version, we could start the Wireshark capture and  engage the SMB service
using **enum4linux** or **smbclient**.

We can use the display filter

```
smb and ip.src=={IP}
```

to filter the packets to only SMB responses from the target.
Follow the TCP stream to find the version number.

* **Using custom scripts**

[smbver.sh](https://raw.githubusercontent.com/rewardone/OSCPRepo/master/scripts/recon_enum/smbver.sh)

Kudos to the creator [rewardone](https://github.com/rewardone/OSCPRepo).

Also thanks to [0xdf](https://0xdf.gitlab.io/2018/12/02/pwk-notes-smb-enumeration-checklist-update1.html#manual-inspection).




